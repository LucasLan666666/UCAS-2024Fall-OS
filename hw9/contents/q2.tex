\question {
    假设一台计算机给每个进程都分配 4 个物理页框，每个页框大小为 1KB。现有一个程序对一个二维
    整数数组（{\tt uint32 X[32][32]}）进行赋值操作，该程序的代码段占用一个固定的页框，并
    一直存储在内存中。程序使用剩余 3 个物理页框存储数据。该程序操作的数组{\tt X}以列存储形
    式保存在磁盘上，即{\tt X[0][0]}后保存的是{\tt X[1][0]}、{\tt X[2][0]}...
    {\tt X[31][0]}，然后再保存{\tt X[0][1]}，以此类推。当程序要赋值时，如果所赋值的数组
    元素不在内存中，则会触发 page fault，操作系统将相应元素以页框粒度交换至内存。如果该进程
    的物理页框已经用满，则会进行页换出。该程序有如下两种写法。
}

（原代码与题干不符，这里个人纠正为32）

写法1：
\begin{lstlisting}[language=C]
for(int i=0;i<32;i++)
    for(int j=0;j<32;j++)
        X[i][j] = 0;
\end{lstlisting}

写法2：
\begin{lstlisting}[language=C]
for(int j=0;j<32;i++)
    for(int i=0;i<32;j++)
        X[i][j] = 0;
\end{lstlisting}

请分析使用这两种写法时，各自会产生多少次 page fault？（注：请写出分析或计算过程）

\begin{solution}

因为页框大小为 1KB，数组元素大小为 4B，所以每个页框可以存储 256 个元素。而数组按列存储，并且一
列有 32 个元素，所以每列占用 32*4B=128B，即占用 1/8 个页框。因此，数组 X 占用的物理页框数
为 32/8=4。

因为该进程只有 4 个物理页框，并且有 1 个物理页框用于存储代码段，所以同一时间只有 3 个物理页框能
存储在内存中。

写法 1 是按行遍历。当遍历第 0 行时，访问前 24 个元素会触发 3 次 page fault，同时将内存中的
3 个物理页框占满。访问第 0 行最后 8 个元素时，会触发 1 次 page fault，此时会将之前 3 个物理
页框的其中 1 个换出。因此，写法一在遍历第 0 行时会产生 4 次 page fault，之后遍历 1-31 行时
如果替换算法较好的话（比如最优替换策略），每行仅会产生 1 次 page fault，总共产生 $4+31=35$
次 page fault。

写法 2 是按列遍历。当遍历 0-23 列时，会触发 3 次 page fault，同时将内存中的 3 个物理页框占满。
访问第 24 列时，会触发 1 次 page fault，此时会将之前 3 个物理页框的其中 1 个换出。因此，写法
二总共产生 $3+1=4$ 次 page fault。


\end{solution}
