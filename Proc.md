# 进程和线程

## **进程**

### 进程的概念

#### 进程的定义

- 进程是指一个具有一定**独立功能**的程序在一个**数据集合**上的一次**动态**执行过程
- 进程刻画了一个程序运行所需要的资源

#### 程序 vs 进程

- 进程 > 程序：
    - 程序只是进程状态的一部分
    - 举例：多个用户可以运行相同程序
- 进程 < 程序：
    - 一个程序可以创建多个进程
    - 举例：`fork`

#### 进程并行性

- 虚拟化
    - 对 CPU 时分复用
- I/O 并行性
    - CPU 计算与 I/O 操作交叠
- CPU 并行性
    - 多核

### 进程的表示

#### 进程控制块(PCB)

- 进程标识信息
- CPU 相关
    - 状态：就绪、运行、阻塞
    - 寄存器，EFLAGS，其他 CPU 状态
- 内存管理信息
    - 栈，代码段，数据段
    - 段，页表，统计信息等
- I/O 和文件管理
    - 通信端口，目录，文件描述符等

#### 进程原语(Primitives)

- 创建和终止
    - `exec`, `fork`, `wait`, `kill`
- 信号
    - 动作，返回，信号处理函数
- 操作
    - 阻塞，放弃 CPU 控制权(yield)
- 同步

### 进程的状态

#### 进程的生命周期

- 创建
    - 系统初始化时
    - 用户请求创建新进程
    - 正在运行的进程执行`exec`系统调用
- 执行
    - 内核选择一个就绪进程，为其分配时间片
- 等待(只有进程自身才能知道何时需要等待某种事件的发生)
    - 进程等待系统服务
    - 启动某种操作，无法立即完成
    - 需要数据未到达
- 抢占(抢占式内核)
    - 高优先级进程就绪
    - 时间片用完
- 唤醒(抢占式内核)(只能被别的进程或操作系统唤醒)
    - 被阻塞进程许需要资源被满足
    - 被阻塞进程等待的事件到达
- 终止

#### 进程切换

- 保存上下文
    - 所有通用寄存器和浮点寄存器
    - 所有协处理器状态
    - 需要保存内存吗？
    - Cache and TLB？

- 开始新上下文
    - 与上述相反

- 挑战：如何做到不改变寄存器的值？
    - CISC：特殊指令直接保存和恢复所有寄存器
    - RISC：为内核预留寄存器(`scrach`?)或(have way to carefully saveone and then continue)

#### 三条公理

- 用户态和内核态是两个世界
- 中断和异常是用户态进入内核态的入口
- 每个进程的地址空间是独立的

## **线程**

进程是操作系统进行**资源分配**的最小单元，线程是操作系统进行运算**调度**的最小单元。

### 线程的概念

- 线程是进程的一部分，描述指令流执行状态，是 CPU 调度的基本单位
- 线程在同一个进程的地址空间中运行，可共享变量

### 线程的表示

#### 线程控制块(TCB)

- 状态：就绪、运行、阻塞
- 寄存器
- 栈

#### 典型线程 API

- 创建：`pthread_...`
- 互斥：`acquire`，`release`
- 条件变量：`wait`，`signal`，`broadcast`
- 警报：`alart`，`alertwait`，`testalert`

#### 进程 vs 线程

- 地址空间
    - 进程：独立，会切换页表和其他内存机制
    - 线程：共享
- 权限
    - 进程：独立
    - 线程：共享

#### 线程上下文切换

- 在线程的栈或 TCB 上保存上下文
- 如果保存在栈上，保存前**检查是否溢出**
- 如果保存在 TCB 上，效率会低一些

#### 线程 vs 过程

- 线程可能**乱序恢复**
    - 不能用栈保存状态
    - 每个线程有自己的栈
- 线程**切换不会太频繁**
    - 不会划分寄存器
    - 线程有自己 CPU
- 线程可以是**异步**的
    - 过程可以利用编译器异步保存状态(编译器插桩，用于)
    - 线程可以异步运行
- 多线程
    - 多线程可以并行运行在多个 CPU 上
    - **过程调用是顺序的**

### 线程的分类

- 用户线程
    - 由用户空间线程库管理，TCB 在用户空间
    - 内核不知道线程的存在
- 内核线程
    - 由内核管理，TCB 在内核空间
- 轻量级进程(LWP)
    - 内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持

用户线程与内核线程关系：一对一 or 多对一，区别是**是否共享内核栈**

## **非抢占式调度**

通过`block()`和`yield()`等函数主动让出 CPU

## **抢占式调度**

通过**中断**进行抢占，发生在指令之间或一条**非原子指令**执行期间

### 抢占式调度的中断处理

- I/O 中断处理
- 时钟中断处理

### 用户线程 vs 内核线程

主要区别是使用的调度器。

- 用户级线程
    - **用户级线程库**实现线程上下文切换
    - 时间中断会引入抢占
    - 当用户级线程被 I/O 事件阻塞时，整个进程都会被阻塞(前提，用户线程和内核线程多对一的情况)
- 内核级线程
    - 内核级线程被**内核调度器**调度
    - 由于**跨越了保护边界**，内核级线程的上下文切换开销远大于用户级线程

## **CPU 调度**

### CPU 调度基础

- 什么时候调度？
    - 线程/进程的创建
    - 线程/进程的终止
    - I/O 阻塞、同步
    - I/O 中断
    - 时钟中断
- 调度准则
    - 公平性
    - 每个作业都有机会运行，没人“饥饿”
    - CPU 资源利用率
    - 吞吐率
    - 周转时间
    - 响应时间
    - 均衡性

### CPU 调度算法

- **响应时间**：从提交第一个请求到第一次响应的时间
- **周转时间**：从作业提交到完成的时间
- **等待时间**：作业在就绪队列中等待的时间

#### 先到先服务(FCFS)

- 非抢占式

- **优点**：
    - 简单
- **缺点**：
    - 不公平，平均响应时间波动较大
    - I/O 资源和 CPU 资源利用率较低

#### 最短时间优先(STCF)

- 非抢占式

##### 最短剩余时间优先(SRTCF)

- 抢占式

- 调度器如何实现？
    - 就绪队列按剩余时间排序
    - 选择剩余时间最短的进程进入运行状态
- **优点**：
    - **平均响应时间最短**
- **缺点**：
    - 可能导致饥饿：连续短进程导致长作业可能永远无法运行
    - 需要预测剩余时间：一个简单方法是询问用户

#### 时间片轮转(Round Robin)

- 抢占式

- 增加了时间片，时间片结束时，调度器按 FCFS 算法切换到下一个就绪进程

- 大时间片
    - 等待时间长，极端情况下退化为 FCFS
- 小时间片
    - 响应时间快
    - 上下文切换开销大

#### 虚拟轮转(Virtual Round Robin)

- 引入**辅助队列**
- I/O 密集型进程在辅助队列中等待
- 辅助队列有更高的优先级

#### 多级队列(MQ)与优先级

- 将就绪队列分为多个独立的子队列，每个队列可有自己的调度算法
- 队列之间
    - 每个队列分配一个优先级与相应时间片
    - 队列间按照时间片调度

##### 多级反馈队列(MLFQ)

进程**可在不同队列间移动**的多级队列算法

- 时间片大小随优先级级别增加而增加
- 进程在当前的时间片没有完成，则降到下一个优先级
- **CPU 密集型进程的优先级下降很快，I/O 密集型进程停留在高优先级**

#### 彩票调度

- 动机
    - SRTCF 可以保证平均响应延迟，但是不公平
- 彩票方法
    - 给每个作业一定数量的彩票
    - 随机抽取一张中奖彩票(winning ticket)
    - 为了近似 SRTCF，给**短作业更多的彩票**
    - 为了避免“饥饿”，给每个作业**至少一张彩票**
    - 相互合作的进程可以交换彩票

#### 公平共享调度(FSS)

- FSS 控制用户对系统资源的访问
    - 一些用户组比其他用户组更重要
    - 保证不重要的组无法垄断资源
    - 未使用的资源按比例分配
    - 没有达到资源使用率目标的组获得更高的优先级

#### 多处理器/集群调度

- 多处理器架构
    - Cache 一致性
    - 单独一个 OS
- 集群
    - 分布式内存
    - 每个“盒子”各一个 OS

#### 实时调度

- 硬实时
    - 任务必须在截止时间前完成
- 软实时
    - 大多数时候满足，没有强制性

- 接纳控制
    - 只有当系统能够保证所有进程的实时性的前提下，新的实时进程才会被接纳
    - 如果满足下面的条件，作业就是可调度的：$\Sigma \frac{C_i}{T_i} \le 1$($C_i$：计算时间，$T_i$：周期)

##### 速率单调调度

- 基本思想
    - 给每个进程分配一个固定的优先级=出现频率
    - 按照进程优先级从高到低
    - 证明是最优的

##### 最早最终时限优先调度(EDF)

- 根据最终时限对就绪的进程进行排序
- 运行列表中的第一个进程（最早最终时限优先）
- 当新的进程就绪时，并且其最终时限快来临时，它会抢占当前进程

#### BSD 多队列调度

- 进程如果在 1 秒内没有阻塞或者完成，则会被抢占
- 优先级每秒重新计算

#### 总结

- 较小的时间片有利于提高 I/O 利用率
- STCF 和 SRTCF 可以获得最小的平均响应时间
- 优先级调度和其变种普遍存在于多个系统中
- 彩票调度的灵活性很好
- 实时调度依赖于接纳控制(admission control)
