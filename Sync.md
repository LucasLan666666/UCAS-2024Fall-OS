# 同步与通信

## 基本概念

### 通信

- 多线程通信可直接共享缓冲区
- 多进程通信需要经过**操作系统内核**

- 通信两大作用
  - 信息同步：保证多个线程或进程之间正确使用共享资源
  - 数据传输：便于将单个任务切分、模块化，提高并发度

### 同步

- **临界区**：进程中访问临界资源的一段**需要互斥执行的代码**
- **原子操作**：原子操作是指一次**不存在任何中断或失败**的操作
  - 要么成功，要么不执行
  - 对临界区的操作必须是原子操作

#### 临界区的保障

忙则等待，空闲则入

- 基于软件的方法：
  - **共享变量**来同步：`Peterson`算法(双线程)，`Eisenberg`和`McGuire`算法(多线程)
  - **复杂**：需要两个线程共享数据项
  - 需要忙等待，浪费 CPU 时间
- 硬件中断：
  - 通过在`acquire`和`release`之间禁止上下文切换来提供互斥
  - 禁用中断后，进程无法被停止，整个系统停下来，可能导致其他进程饥饿
  - 临界区可能很长，无法确定响应中断所需的时间(硬件影响)
  - 只用于**单核处理器**
- 原子操作指令与互斥锁：
  - `Test-and-Set`
  - `exchange`
  - `Fetch-and-Add`、`Fetch-and-Op`
  - `Load-Linked`、`Conditional-Store`

## 死锁

### 定义

- 资源：
  - 可抢占： CPU
  - 不可抢占：磁盘、文件、互斥锁...
- 使用资源：
  - 请求、使用、释放
- 饥饿
- 死锁
  - 一个进程集合死锁，如果集合中所有进程都在等待一个事件，且等待的事件只能由集合中其它进程触发

### 必要条件

这四个条件都是必要的：

- **互斥**：线程对于需要的资源进行互斥的访问(例如一个线程抢到锁)
- **占有并等待**：线程持有了资源(例如已将持有的锁)，同时又在等待其他资源(例
如，需要获得的锁)
- **不可抢占**：线程获得的资源(例如锁)，不能被抢占
- **环路等待**：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的

### 策略

#### 忽略问题——鸵鸟算法

- 重启！
- 挂起！

#### 检测和恢复

- 检测：
  - 周期性检测死锁
- 恢复(困难)：
  - 杀死进程/线程
  - 回滚

#### 避免

**银行家算法**

#### 预防

破坏死锁的四个必要条件之一

- **避免互斥**
  - 无等待数据结构(原子指令)
  - 有些资源物理上不可共享
  - 有些可以设置为可共享
  - 有些可以通过假脱机进行虚拟化
- **避免占有并等待**
  - 原子地枪锁，抢一把大锁
- **允许抢占**
  - 方法
    - 如果系统无法满足一个已占有资源的进程的请求，抢占该进程并释放所有资源
    - 只在系统能满足所有资源时进行调度
  - 其他方法
    - 抢占占有被请求的资源的进程
- **避免环路等待**
  - 为资源排序，按顺序申请

## 信号量(Semaphores)

信号量是操作系统提供的一种协调共享资源访问的方法。

- 信号量组成
  - 一个整形变量，表示系统资源的数量
  - 两个原子操作组成
    - `P`操作：等待信号量为正，然后$-1$
    - `V`操作：信号量$+1$

## 管程

管程是一种用于多线程互斥访问共享资源的程序结构。

- 组成
  - 一个锁：控制管程代码的互斥访问
  - 0 或多个条件变量：管理共享数据的并发访问

### `Signal`之后的选择

- 让被唤醒的线程立即执行，并**挂起发送方**(Hoare)
  - 如果发送方有其他工作要做，会很麻烦
  - 很难确定没有其他工作要做，因为`Signal`的实现并不知道它是如何被使用的
- **退出**管程(Hansen)
  - `Signal`必须是管程中的过程的最后一个语句
- **继续**执行 (Mesa)
  - 易于实现
  - 然而，被唤醒的进程实际执行时，条件可能不为真

### Mesa 风格管程


## 生产者——消费者问题

- 任何时刻**只能有一个线程**操作缓冲区(互斥访问)
- 缓冲区空时，消费者必须等待生产者(条件同步)
- 缓冲区满时，生产者必须等待消费者(条件同步)

### 信号量实现

```c++
BoundedBuffer::Deposit(c)
{
  emptyBuffers->P();
  mutex->P();
  Add c to the buffer;
  mutex->V();
  fullBuffers->V();
}

BoundedBuffer::Remove(c)
{
  fullBuffers->P();
  mutex->P();
  Remove c from the buffer;
  mutex->V();
  emptyBuffers->V();
}
```

### 管程实现

```c++
BoundedBuffer::Deposit(c)
{
  lock->Acquire();
  while (count == n)
    notFull.Wait(&lock);
  Add c to the buffer;
  count++;
  notEmpty.Signal();
  lock->Release();
}

BoundedBuffer::Remove(c)
{
  lock->Acquire();
  while (count == 0)
    notEmpty.Wait(&lock);
  Remove c from the buffer;
  count--;
  notFull.Signal();
  lock->Release();
}
```

## 屏障(Barrier)

- 功能
  - 指定一个屏障变量
  - 广播给其他 n-1 个线程
  - 若屏障变量的值达到 n，则继续

## 哲学家就餐问题

一个解决方案：

```c
#define   N   5         // 哲学家个数
semaphore fork[5];        // 信号量初值为 1

void philosopher(int i)     // 哲学家编号：0 － 4
{
  while(TRUE) {
    think();        // 哲学家在思考
  if (i%2 == 0) {
    P(fork[i]);       // 去拿左边的叉子
    P(fork[(i + 1) % N]);   // 去拿右边的叉子
  } else {
    P(fork[(i + 1) % N]);   // 去拿右边的叉子
    P(fork[i]);       // 去拿左边的叉子
  }
  eat();            // 吃面条中....
  V(fork[i]);         // 放下左边的叉子
  V(fork[(i + 1) % N]);     // 放下右边的叉子
  }
}
```

## 读者——写者问题

-  问题描述
  - “读——读”允许
  - “读——写”互斥
  - “写——写”互斥

### 信号量实现

- 约束：
  - 信号量`WriteMutex`：初始化为 1 ，控制读写互斥
  - 读者计数`Rcount`：初始化为 0 ，当前正在读操作读者数量
  - 信号量`CountMutex`：初始化为 1 ，控制读者计数的互斥修改

`Writer`：
```c++
P(WriteMutex);
  write();
V(WriteMutex);
```

`Reader`：
```c++
P(CountMutex);
  if (Rcount == 0) // 第一个读者会锁住写者
    P(WriteMutex);
  Rcount++;
V(CountMutex);

read();

P(CountMutex);
  Rcount--;
  if (Rcount == 0) // 最后一个读者会释放写者
    V(WriteMutex);
V(CountMutex);
```

### 管程实现

```c++
...
```

## 进程间通信

不同进程间进行通信和同步的机制。

### 消息队列

- 消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制
- 每个消息(Message)是一个字节序列
- 相同标识的消息组成按先进先出顺序组成一个消息队列

### 共享内存

- 共享内存是操作系统把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制
- 每个进程将共享内存区域映射到私有地址空间
- 优点：快速、方便地共享数据
- 缺点：必须用额外的同步机制来协调数据访问

### 管道

- 进程间基于内存文件的通信机制
  - 子进程从父进程继承文件描述符
- 缺省文件描述符：`0 stdin` , `1 stdout` , `2 stderr` 进程不知道（或不关心！）的另一端
  - 可能从键盘、文件、程序读取
  - 可能写入到终端、文件、程序

### 信号

- 进程间的软件中断通知和处理机制
- 信号接收处理：
  - 捕获
  - 忽略
  - 屏蔽
- 不足
  - 传送信息量小

### 同步和异步

异步方式允许并发，但需要仔细的设计。

- **发送**
  - 同步：
    - 启动数据传输
    - 直到源缓冲用完后再阻塞
  - 异步：
    - 启动数据传输并且立即返回

- **接收**
  - 同步：有消息则返回数据
  - 异步：有消息则返回数据，否则返回状态