# 操作系统简介

## 什么是操作系统

- 在应用和硬件之间的一层软件
- 对上层软件提供硬件的抽象
- 对底层硬件进行管理：共享和隔离
- 对底层硬件的处理：细节实现

## 操作系统能做什么

- 抽象与分层
- 资源管理、共享与隔离
- 系统保护
- 屏蔽硬件

## **操作系统结构**

### 典型的 UNIX 操作系统结构

- 用户层
    - **应用(Application)**：程序员编写并编译
    - **库(Libraries)**：精心设计、预编译好、头文件定义、连接器引入、类似函数调用、加载时必须定位
- 内核层
    - **可移植层(Portable Layer)**：系统调用功能集合
    - **机器相关层(Machine-Dependent Layer)**：启动、初始化、中断、例外、IO 驱动、内存管理、处理器调度、模式切换

### 一个程序的生命周期

#### 生成一个可执行文件

GCC 编译、汇编、链接各模块

- **编译器**(GCC 的一部分)将程序编译成汇编文件
- **汇编器**将汇编代码编程可重定位的对象文件
- **链接器**将多个对象文件链接成一个可执行文件

#### 加载和运行

Linux 下，由**加载器**(Loader)完成：

-  读一个可执行文件
-  放置代码、数据、堆和栈
-  动态链接到共享库
-  更新 OS 核心数据结构
-  运行应用

#### 应用程序的结构

四个段：

- **栈**：
    - 由编译器布局
    - 进程创建或结束时分配/释放
    - 相对于栈指针寻址，局部
- **堆**：
    - 链接器和加载器确定起始地址
    - 由库函数malloc()/free()等进行分配和释放
    - 应用程序通过库函数进行管理，可能随机分配
- **代码段**/**数据段**：
    - 编译器静态分配，产生名字和符号索引
    - 链接器翻译索引和重定位地址
    - 加载器最终完成在内存的布局

## **操作系统组成**

- 处理器管理
- 内存管理
- I/O 管理
- 文件系统
- 窗口系统(GUI)
- 启动(BootStrap)

### 操作系统启动过程

- 计算机上电
- 处理器 Reset
    - 设置到初始状态
    - 跳转到 ROM 代码(BIOS)
    - 初始化启动所需最少的设备
- 从持久存储加载Boot Loader
- 跳转到 Boot Loader 执行
- 加载 OS 其余的部分
- 初始化 OS 并运行

## **保护机制**

保护和安全的区别？

保护是一种**机制**和**手段**，**安全**是目标

- CPU
    - 内核有能力抢走用户 CPU
    - 用户不行
- 内存
    - 防止用户修改其他用户的代码数据
    - 防止用户修改内核代码数据
- I/O
    - 防止用户非法 I/O 操作

### 体系结构支持：特权态

- 用户模式：不能执行特权指令，不能访问内核内存

- 内核(特权)模式：可以执行所有指令，访问所有内存

## **操作系统结构类型**

### 层次结构

不同层间隐藏信息

- 层功能独立

- 低效率
- 不灵活

### 一体结构(宏内核， Monolithic)

所有操作系统函数一体

- 共享内核地址空间
- 高性能

- 不稳定
- 不灵活

### 微内核(MicroKernel)

操作系统服务作为常规的进程，用户通过消息获取服务进程的服务

- 灵活
- 故障隔离

- 效率低
- 保护机制不完善
- 内核与服务不方便共享数据

### 库操作系统(Lib OS)

应用程序直接通过库与底层硬件交互

- 效率高

- 通用性差

### 虚拟机

- 两种实现 VMM 模式：
    - 裸机虚拟化：直接运行在硬件上
    - 宿主虚拟化：运行在宿主操作系统上
- 全硬件隔离：无需虚拟机

## **系统调用和库函数**

系统调用是应用和操作系统之间的接口

- 种类：
    - 进程管理
    - 内存管理
    - 文件管理
    - 设备管理
    - 通信

### 实现

系统调用产生异常，进行 OS 状态切换

系统调用机制：

1. 假设：
    - 用户代码任意
    - 用户无法修改核心内存

2. 设计考虑：
    - 系统调用传参
    - 用户态切换到内核态(例如 x86 的 `int 0x80`)
    - 执行系统调用
    - 返回结果，切换回用户态(`iret`)

### 参数传递

- 寄存器传参
- 内存向量(数组)传参
    - 一个寄存器传递起始地址
    - 向量位于用户地址空间
- 堆栈传参
    - 类似内存向量
    - 遵循过程调用规范

### 系统调用流程

```
EntryPoint:
    switch to kernel stack
    save context
    check $R_0$
    call the real code pointed by $R_0$
    place result in $R_0$
    restore context
    switch to user stack
    iret(change to user mode and return)

(Assume passing parameters in registers)
```

### 设计考虑

(讲义未提供答案，以下为个人搜集资料整合后的理解)：

- 只有一个结果寄存器，更多结果怎么办？
    - 多个寄存器
    - 指针参数
- 怎么把错误返回给调用者？
    - 操作系统错误码(如`errno` ，标准库提供)
- 用户代码是否可以撒谎？
    - 可以，但是会被操作系统检查
    - 参数验证
    - 指针检查
    - 边界检查
    - 权限检验
    - 错误处理
- 怎么保证系统调用质量？
- 什么应该是系统调用，什么应该是库函数调用？
    - 看是否涉及到进程管理、内存管理、文件管理、设备管理、通信。

### 系统调用对程序的反馈

(讲义未提供答案，以下为个人搜集资料整合后的理解)：

- 应用看系统调用和函数调用都是过程调用
- 操作系统需要应用做什么？
    - 各种例外的条件
    - 一般信息的改变(屏幕尺寸调整)
- 操作系统采用什么机制通知用户程序？
    - 操作系统可以通过信号、回调函数、轮询和事件驱动等机制通知用户程序。选择哪种机制取决于具体的应用场景和需求。信号适用于异步通知，回调函数适用于同步通知，轮询适用于简单的状态检查，而事件驱动适用于高效的事件处理。
